theory Init_process
begin

builtins: hashing, asymmetric-encryption

rule Init_NodeB:
    [
        Fr(~ltkNodeB)
    ]
    -->
    [
        !Ltk($NodeB, ~ltkNodeB),
        !Pk($NodeB, pk(~ltkNodeB)),
        Out(pk(~ltkNodeB))
    ]

rule Init_User:
    [
        Fr(~ltkUser)
    ]
    --[ UserCreated($User, ~ltkUser) ]->
    [
        !Ltk($User, ~ltkUser)
    ]

rule Init_User_Request:
    [
        Fr(~n),
        !Ltk($User, ~ltkUser),
        !Pk($NodeB, pkNodeB)
    ]
    -->
    [
        Out(aenc(<$User, pk(~ltkUser)>, pkNodeB)),
        State($User, <$NodeB, ~n>)
    ]

rule NodeB_Process:
    let 
        content = adec(ciphertext, ~ltkNodeB)
        User = fst(content)
        receivedKey = snd(content)
    in
    [
        In(ciphertext),
        !Ltk($NodeB, ~ltkNodeB),
        Fr(~reply_n)
    ]
    --[ Finished($NodeB, User) ]->
    [
        !LearnedKeysNodeB($NodeB, <User, receivedKey>),
        Out(aenc(~reply_n, receivedKey)),
        State($NodeB, <User, 'init'>)
    ]

lemma User_Key_Secretary:
    "All user key #i.
        UserCreated(user, key) @i
        ==>
        not (Ex #j. K(key) @j)"

lemma Functional_Test:
    exists-trace
    "Ex node user #i.
        Finished(node, user) @i"

end