
// builtins: hashing, asymmetric-encryption, signing

rule Init_NodeB:
    [
        Fr(~ltkNodeB)
    ]
    -->
    [
        !Ltk($NodeB, ~ltkNodeB),
        !Pk($NodeB, pk(~ltkNodeB)),
        Out(pk(~ltkNodeB))
    ]

rule Init_User:
    [
        Fr(~ltkUser)
    ]
    --[ UserCreated($User, ~ltkUser) ]->
    [
        !Ltk($User, ~ltkUser)
    ]

rule Init_User_Request:
    [
        !Ltk($User, ~ltkUser),
        !Pk($NodeB, pkNodeB),
        Fr(~init_vc),
        Fr(~init_message),
        Fr(~n)
    ]
    -->
    [
        Out(aenc(<$User, pk(~ltkUser), ~init_vc, ~init_message, ~n>, pkNodeB)),
        State($User, <$NodeB, 'request', ~init_vc, ~init_message, ~n>)
    ]

rule NodeB_Process:
    let 
        content = adec(ciphertext, ~ltkNodeB)
        User = fst(content)
        receivedKey = fst(snd(content))
        init_vc = fst(snd(snd(content)))
        init_message = fst(snd(snd(snd(content))))
        nonce = snd(snd(snd(snd(content))))

        payload = <~reply_init_vc, ~post_init_vc_location, h(nonce)>
        signature = sign(payload, ~ltkNodeB)
    in
    [
        In(ciphertext),
        !Ltk($NodeB, ~ltkNodeB),
        Fr(~reply_init_vc),
        Fr(~post_init_vc_location)
    ]
    --[ Finished($NodeB, User) ]->
    [
        !LearnedKeysNodeB($NodeB, <User, receivedKey>),
        Out(aenc(<payload, signature>, receivedKey)),
        State($NodeB, <User, 'init'>)
    ]

rule User_Branching:
    let 
        decrypted_box = adec(reply_ciphertext, userKey)
        payload = fst(decrypted_box)
        signature = snd(decrypted_box)

        reply_init_vc = fst(payload)
        post_init_vc_location = fst(snd(payload))
        nonce = snd(snd(payload))
    in
    [
        In(reply_ciphertext),
        State($User, <$NodeB, 'request', init_vc, init_message, n>),
        !Ltk($User, userKey),
        !Pk($NodeB, pkNodeB),
        Eq(h(n), nonce) 
    ]
    --[ User_Passes_Initialization($User, reply_init_vc, post_init_vc_location) ]->
    [
        Eq(verify(signature, payload, pkNodeB), true),
        State($User, <$NodeB, 'response', reply_init_vc, post_init_vc_location>)
    ]


lemma User_Key_Secretary:
    "All user key #i.
        UserCreated(user, key) @i
        ==>
        not (Ex #j. K(key) @j)"

lemma Functional_Test:
    exists-trace
    "Ex node user #i.
        Finished(node, user) @i"

lemma User_Receives_Response:
    "All user reply_vc loc #i.
        User_Passes_Initialization(user, reply_vc, loc) @i
        ==>
        ( not (Ex #j. K(reply_vc) @j) )
        &
        ( not (Ex #k. K(loc) @k) )"    

